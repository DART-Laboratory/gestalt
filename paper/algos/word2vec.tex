\begin{algorithm}[!t]
    \scriptsize
    \DontPrintSemicolon
    \SetKwInOut{Input}{Inputs}
    \SetKwInOut{Output}{Output}
    \Input{Client Word2Vec models $\{Word2vec_1, Word2vec_2, \ldots, Word2vec_N\}$.}
    \Output{Harmonized Word2Vec model $M_{\text{w2v-harm}}$ sent to clients.}
    \BlankLine
    \tcc{Central server distribute symmetric encryption keys to each client.}
    \ForEach{client $C_i$}{
  
      Send $key$ to $C_i$\\
    }
    \tcc{Clients encrypt their model tokens.}
    \ForEach{client model $word2vec_i$}{
      $Word2vec_i \leftarrow$ EncryptModelTokens($Word2vec_i$, $E$) \tcc*{Encrypt tokens using $E$.}
      Send $Wor2vec_i$ to Utility Server\\
    }
    \tcc{Utility server merges encrypted models.}
    $TokenVectors \leftarrow$ InitializeEmptyDictionary()\\
    $TokenCounts \leftarrow$ InitializeEmptyDictionary()\\
    \ForEach{encrypted model $Word2vec_i$}{
      \ForEach{token $t$ in $Word2vec_i$}{
        $Vector \leftarrow Word2vec_i[t]$\\
        \eIf{$TokenVectors$.HasKey($t$)}{
          $TokenVectors[t] \leftarrow TokenVectors[t] + Vector$\\
          $TokenCounts[t] \leftarrow TokenCounts[t] + 1$\\
        }{
          $TokenVectors[t] \leftarrow Vector$\\
          $TokenCounts[t] \leftarrow 1$\\
        }
      }
    }
    \tcc{Average the vectors for overlapping tokens.}
    \ForEach{token $t$ in $TokenVectors$.Keys()}{
      $TokenVectors[t] \leftarrow TokenVectors[t] / TokenCounts[t]$\\
    }
    $M_{\text{w2v-harm}} \leftarrow$ NewModel($TokenVectors$, $EncryptedTokens$) \tcc*{Constructing a new harmonized model.}
    \ForEach{client $C_i$}{
      Send $M_{\text{w2v-harm}}$ to $C_i$\\
    }
    \BlankLine
    \Return{Harmonized model $M_{\text{w2v-harm}}$ has been dispatched to all clients.}\\
    \BlankLine
    \caption{Privacy-preserving \wordvec Model Harmonization.}
    \label{alg:secure_integration_averaging_word2vec}
  \end{algorithm}